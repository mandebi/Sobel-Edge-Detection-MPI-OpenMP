#include "mpi.h"
#include <omp.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>

#define MASTER 0               /* taskid of first task */
#define FROM_MASTER 1          /* setting a message type */
#define FROM_WORKER 2          /* setting a message type */
#define DEBUG 0
#define MAX_INT 100 //Maximum integer generated by the random function
#define MIN_INT 0 // Minimum integer generated by the random function

#define N 3000



int result_image [N][N];


struct timespec begin, end;
double time_spent;
int rec_buf[10000000]; 
int send_buf[10000000];  
int *sendcounts;// array describing how many elements to send to each process
int *displs; // array describing the displacements where each segment begins
	

/*   ttype: type to use for representing time */
typedef double ttype;
ttype tdiff(struct timespec a, struct timespec b)
/* Find the time difference. */
{
  ttype dt = (( b.tv_sec - a.tv_sec ) + ( b.tv_nsec - a.tv_nsec ) / 1E9);
  return dt;
}

struct timespec now()
/* Return the current time. */
{
  struct timespec t;
  clock_gettime(CLOCK_REALTIME, &t);
  return t;
}


void printArray(int** A){
	int i, j;
	
	for(i=0;i<N;i++){
      for(j=0;j<N;j++)
        printf(" %d", A[i][j]);
      printf("\n");	
	}		  
}


int** load_image(int** input_image){
	
  FILE *fp;	
  int i,j, num;
  
  
    input_image = (int **) malloc( N*sizeof(int*));
	 	
    for (i=0; i<N; i++){ 
         input_image[i] = (int *)malloc(N * sizeof(int)); 
    }	
  
  
  fp = fopen("input.txt", "r");
  
  if(fp == NULL) {
    printf("Error in opening file\n");
    exit(1);
  }
  
  i = 0;
  j = 0;  
  while( fscanf(fp, "%d", &input_image[i][j])!=EOF ) 	  
   {
      //printf(" input_image[%d][%d] = %d \n", i,j,input_image[i][j]);
	  j++;
	  if(j==N){
		  j = 0;
		  i++;
	  }
   }
   //printArray(input_image);

   return input_image;
   
  fclose(fp);	
}

void save_image(){
	
  FILE *fp;	
  int i,j, num,taskid,numtasks;
  
  MPI_Comm_rank(MPI_COMM_WORLD,&taskid);
  MPI_Comm_size(MPI_COMM_WORLD,&numtasks);	
  
  
  if (0 == taskid) {
	  
	  fp = fopen("output.txt", "w");
	  if(fp == NULL) {
		printf("Error in opening file\n");
		exit(1);
	  }
	  
	  for(i=0;i<N;i++){
		  for(j=0;j<N;j++)
			  if(j == 0)
				 fprintf(fp, "%d", result_image[i][j]); 
			  else
				fprintf(fp, " %d", result_image[i][j]);			  
		fprintf(fp, "\n");	
	  }	 	  

  fclose(fp);	
  }
}


	
		 
void collect_results (int **Ap){
   int i,j,taskid,numtasks, r,offset=0,counter;	
  
   int* data;

   MPI_Comm_rank(MPI_COMM_WORLD,&taskid);
   MPI_Comm_size(MPI_COMM_WORLD,&numtasks);	
   
   data = (int*)calloc( N*N,sizeof(int));
   
   Ap = (int **) malloc( N*sizeof(int*));
    for (i=0; i<N; i++){
         Ap[i] = (int *)malloc(N * sizeof(int)); 	 
	}
   
   for (i = 0; i < numtasks; i++) { // we add an offset to prevent rank i from overwriting the 1st line
         sendcounts[i]=sendcounts[i]-(2*N);
	     displs[i] = offset;
	   
       offset+=sendcounts[i];
	   /*if (0 == taskid){
		printf(" ####### RANK %d -- Final Printing sendcounts[%d]=%d\tdispls[%d]=%d \n",taskid,i,sendcounts[i],i,displs[i]);  
	   }*/
   }
   
   // if (0 == taskid) {
    /*counter = 0;
    for (i = 0; i < N; i++){ 
	 for (j = 0; j < N; j++){
        if(counter < 50){		 
          printf("COLLECT - RANK %d (Before MPI_Gatherv) -- send_buf[%d] = %d \n", taskid, counter,send_buf[counter]);  
		  counter++;
		}
        else 
          break;			
	  }	
	}*/
  // }
   
   MPI_Gatherv(send_buf, sendcounts[taskid], MPI_INT, data, sendcounts, displs, MPI_INT,  0, MPI_COMM_WORLD);   
  
   end = now();
   time_spent = tdiff(begin, end); 

   if (0 == taskid) {
	   /*counter = 0;
	   printf("\n\n");
		for (i = 0; i < N; i++){ 
		 for (j = 0; j < N; j++){ 
		   if(counter < 300){
			printf("COLLECT - RANK %d (After MPI_Gatherv) -- send_buf[%d] = %d \n", taskid, counter,send_buf[counter]);  
			counter++;	
		   }
          else
          	break;		  
		  }	
		}*/
	   
	   
	   //printf("     **************** RANK %d -- Result Matrix Ap (%dX%d) **************** \n",taskid, N,N);
      
	  if(DEBUG)
		for(i=0; i< N*N;i++){
		   printf("%d\t", data[i]);	
		    if(((i+1) % N) == 0){
                printf("\n");
            }	
		}
		
	    for (i = 0; i < N; i++) //initialize Ap
	      for (j = 0; j < N; j++)
	          //Ap[i][j] = 0;
		      result_image[i][j] = 0;
		
		r = 0;
        for (i = 1; i < N-1; i++) //Now we copy the buffer into Ap
	      for (j = 0; j < N; j++){
	          if(j!=0 && j!=(N-1))
			   //Ap[i][j] = data[r];
		       result_image[i][j] = data[r];
		       //printf("   >> Ap[%d][%d]=%d -- data[%d]=%d \n",i,j, Ap[i][j],r, data[r]);
			  r++;
		  }
		  
		  
		/*for (i = 0; i < N; i++){ //Now we print Ap
	      for (j = 0; j < N; j++){
	          printf(" %d",Ap[i][j]);
		  }
		  printf("\n");
		}*/			  
			
        //printf ("\n");
		printf("\n  --> MASTER RANK %d total time: %.8f sec\n\n",taskid, time_spent);
		
    }
}	

void mask_operation (int** Ap){
   int i,j,taskid,numtasks, l=0, c=0;	
   int num_line, new_value, counter = 0; 
   int** localMatrix, **resultMatrix;
   int chunk, tid, nthreads;
      	
   MPI_Comm_rank(MPI_COMM_WORLD,&taskid);
   MPI_Comm_size(MPI_COMM_WORLD,&numtasks);	
   
  if(DEBUG){
    printf("\n\nMASK RANK %d --- sendcounts[%d] = %d:\t displs[%d] = %d\n", taskid, taskid, sendcounts[taskid],taskid, displs[taskid]);
    for (i = 0; i < sendcounts[taskid]; i++) {
        printf("%d\t", rec_buf[i]);
    }
	printf("\nnMASK RANK %d -- Done printing the data received !\n", taskid);
    printf("\n");
  }

  num_line =  sendcounts[taskid]/N;	
  localMatrix = (int **) malloc( num_line*sizeof(int*));
  resultMatrix  = (int **) malloc( num_line*sizeof(int*));  
  
    for (i=0; i<num_line; i++){
         localMatrix[i] = (int *)malloc(N * sizeof(int)); 
         resultMatrix[i] = (int *)malloc(N * sizeof(int));		 
	}
	//we copy data in a local matrix to ease the filter computation
    for (i = 0; i < sendcounts[taskid]; i++) {
        localMatrix[l][c] = rec_buf[i];
		c++;
		if(((i+1)%N) == 0){
			l++;
			c = 0;
		}	
    }
	
	if(DEBUG){
	    printf("\n\nRANK %d -- num_line = %d  data_count = %d -- Received (%dX%d) = \n",taskid, num_line,sendcounts[taskid], num_line,N); 	
			for (i = 0; i <  num_line; i++){ 
			  //printf("i=%d    ", i);
			  for (j = 0; j < N; j++){ 
				printf(" %d",localMatrix[i][j]); 
			  }		
			  printf("\n");	  
			}  
	    printf("\n");
	}
	
	
	
	
  #pragma omp parallel shared(resultMatrix,chunk) private(nthreads, tid,i,j,new_value)
   {	
		//Here we perform the filter operation
		#pragma omp for
		for (i = 0; i <  num_line; i++){ 
		  //printf("i=%d    ", i);
		  for (j = 0; j < N; j++){ 
			if(i>0 && i<(num_line-1) && j>0 && j < (N-1)){
				//new_value = (localMatrix[i-1][j-1] + localMatrix[i-1][j] + localMatrix[i-1][j+1]+ localMatrix[i][j-1] + (2*localMatrix[i][j]) + localMatrix[i][j+1]+ localMatrix[i+1][j-1] + localMatrix[i+1][j] + localMatrix[i+1][j+1])/9;		
				new_value = abs( (localMatrix[i-1][j-1]-localMatrix[i+1][j-1]) + 2*(localMatrix[i-1][j]-localMatrix[i+1][j]) + (localMatrix[i-1][j+1]-localMatrix[i+1][j+1]) ) 
								 +abs((localMatrix[i-1][j-1]-localMatrix[i-1][j+1]) + 2*(localMatrix[i][j-1]-localMatrix[i][j+1]) + (localMatrix[i+1][j-1]-localMatrix[i+1][j+1]) );
				resultMatrix[i][j] = new_value;
				//printf("\nRANK %d -- WRITING NEW VALUE into cell[%d][%d] -- localMatrix[i][j]=%d -- resultMatrix[i][j]=%d -- Average computed = %d \n",taskid,i,j,localMatrix[i][j],resultMatrix[i][j], new_value);
			}
			else{
				resultMatrix[i][j] = localMatrix[i][j];
			}
		  }		
		  //printf("\n");	  
		}
   }	
	
	if(DEBUG){
	    printf("\n\nRANK %d -- num_line = %d  data_count = %d -- Processing Result (%dX%d) = \n",taskid, num_line,sendcounts[taskid], num_line,N); 	
			for (i = 0; i <  num_line; i++){ 
			  //printf("i=%d    ", i);
			  for (j = 0; j < N; j++){ 
				printf(" %d",resultMatrix[i][j]); 
			  }		
			  printf("\n");	  
			}  
	    printf("\n");
	}
	
		counter = 0;
	//printf("\n\nRANK %d -- send_buf content(we removed the first and last line from the processin result)= \n",taskid);
	
	//copying back the data to the buffer
	for (i = 1; i <  (num_line-1); i++){ //we do not return the first (i==0) and last lines as the previous worker will computer that line
	 for (j = 0; j < N; j++){		 
        send_buf[counter] = resultMatrix[i][j]; 
        counter++;	
	  }	
      //printf("\n");	 	  
	}	
	

    if(DEBUG){
    counter = 0;
    for (i = 1; i <  (num_line-1); i++){ //we do not return the first (i==0) and last lines as the previous worker will computer that line
	 for (j = 0; j < N; j++){
      if(counter < 50){  		 
         printf("RANK %d    resultMatrix[%d][%d] = %d -- send_buf[%d] = %d \n", taskid, i,j,resultMatrix[i][j], counter,send_buf[counter]);  
         counter++;
       }
        else 
          break; 		
	  }	
      //printf("\n");	 	  
	}
    }
     
   
 	
	
}	



int** initialize_data (int **A){
    
    int i,j,temp,taskid,numtasks, temp1;

    MPI_Comm_rank(MPI_COMM_WORLD,&taskid);
    MPI_Comm_size(MPI_COMM_WORLD,&numtasks);
	
	A = (int **) malloc( N*sizeof(int*));
	
	srand(1);  
    
    temp1 = MAX_INT - MIN_INT + 1; 	
	
    for (i=0; i<N; i++){ 
         A[i] = (int *)malloc(N * sizeof(int)); 
    }	
	 
	//initializing matrix A and Ap
	for (i = 0; i <  N; i++){ 
	  temp = i+1; 
      for (j = 0; j < N; j++){ 
	    A[i][j] = (rand()%temp1) + MIN_INT;
	  }		  
	} 

   /*if (taskid == 0) {		
	//printf("\n >>> The program has started with %d workers\n\n",numtasks);
	    if(DEBUG){
			//printing the content of matrix A 
			printf("     **************** RANK %d -- Initial Matrix A (%dX%d) **************** \n",taskid, N,N); 	
			for (i = 0; i <  N; i++){ 
			  printf("i=%d    ", i);
			  for (j = 0; j < N; j++){ 
				printf(" %d",A[i][j]); 
			  }		
			  printf("\n");	  
			}  
		}
		else{
			//printing the content of matrix A 
			printf("     **************** RANK %d -- Initial Matrix A (%dX%d) **************** \n",taskid, N,N); 		
			for (i = 0; i <  N; i++){ 
			  printf("    ");
			  for (j = 0; j < N; j++){ 
				printf(" %d",A[i][j]); 
			  }		
			  printf("\n");	  
			}  
		}
   }*/
   return A;
}	


void distribute_data (int **A){
int i,j,taskid,numtasks,sum = 0, Nconsidered, start_line, end_line;
int rem, num_lines_to_send, num_data_to_send, max_sendcounts = 0;

int data [N][N];
int k = 0;

MPI_Comm_rank(MPI_COMM_WORLD,&taskid);
MPI_Comm_size(MPI_COMM_WORLD,&numtasks);

if(DEBUG)
  printf("\n>>>> numtasks = %d\t taskid = %d\n",numtasks,taskid);

sendcounts = malloc(sizeof(int)*numtasks);   
displs = malloc(sizeof(int)*numtasks);
         	
	Nconsidered = N-2;
	start_line = 0;

    // we send data per lines
    rem = Nconsidered%numtasks;

    // calculate send counts and displacements
    for (i = 0; i < numtasks; i++) {
		num_lines_to_send = (Nconsidered/numtasks) + 2;
		
		if (rem > 0) {
		  num_lines_to_send++;
          rem--;
        }
		end_line = start_line + (num_lines_to_send-1);

        num_data_to_send = num_lines_to_send * N; //lines and columns		
        sendcounts[i] = num_data_to_send;
        
		if(DEBUG)
           printf("----> taskid = %d\tworker%d\trem = %d\tnum_lines_to_send=%d\tnum_data_to_send=%d\tNconsidered=%d\tstart_line=%d\tend_line=%d\n",taskid,i, rem,num_lines_to_send, num_data_to_send,Nconsidered, start_line,end_line);

		displs[i] = start_line * N;
		start_line = end_line - 1;
    }
      // print calculated send counts and displacements for each process
	  /*if (taskid == 0) {
		printf("\n");   
        for (i = 0; i < numtasks; i++) {
            printf("sendcounts[%d] = %d\tdispls[%d] = %d\n", i, sendcounts[i], i, displs[i]);
        }
	  }*/

   //copying the content of the matrix A into a local variable: for some reason directly using A didn't work with MPI_Scatterv
   for (i = 0; i <  N; i++)
	 for (j = 0; j < N; j++)
	  data[i][j] = A[i][j]; 
			   
  // divide the data among processes as described by sendcounts and displs
  MPI_Scatterv(&data, sendcounts, displs, MPI_INT, &rec_buf, 10000000, MPI_INT, 0, MPI_COMM_WORLD);
  begin = now();	
  // print what each process received
    
    /*printf("\n\nRANK %d --- sendcounts[%d] = %d:\t displs[%d] = %d\n", taskid, taskid, sendcounts[taskid],taskid, displs[taskid]);
	//if (DEBUG) { 
    for (i = 0; i < sendcounts[taskid]; i++) {
        printf("%d\t", rec_buf[i]);
    }
    printf("\n");
   //}*/
}

int main(int argc, char **argv)
{ 
  MPI_Init(&argc, &argv);
  //int N = atof(argv[1]);
  int** A;
  int** Ap;
  int** input_image;
  
  
  //A = initialize_data(A,N);
  input_image = load_image(input_image);

  distribute_data (input_image); // use scatterv
  mask_operation( Ap);
  collect_results(Ap); // use gatherv
  
  save_image();
  MPI_Finalize(); 
  
  return 0;
}